// Simulink CAPI - C++ header only library to interface with code generated by Simulink.
// Copyright (C) 2020-2021  Danish Belal
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License Version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

#ifndef BUS_BUILDER_HPP
#define BUS_BUILDER_HPP

#include "AccessorHelper.hpp"
#include "CapiAccessor.hpp"
#include "CapiError.hpp"
#include "ModelTraits.hpp"

#include "rtw_capi.h"

#include <algorithm>
#include <sstream>
#include <string>

namespace db::simulink
{
template <typename CapiElement, typename ModelStruct, bool EnableExceptions = true>
class BusBuilder
{
    static_assert(is_capi_element<CapiElement>(), "Invalid C-API Element!");
    static_assert(has_datamapinfo_v<ModelStruct>,
        "The Model Structure needs to have a DataMapInfo Member."
        "If it doesnt have one, its either not a Model Structure, "
        "or you didnt enable the C API.");

public:
    BusBuilder(ModelStruct& MS, const std::string& PathAndName)
        : mAccessor(MS)
        , mData(mAccessor.template ptr<void>(PathAndName))
        , mElementMap(GetRawData<rtwCAPI_ElementMap>(MS.DataMapInfo.mmi))
        , mDataTypeMap(GetRawData<rtwCAPI_DataTypeMap>(MS.DataMapInfo.mmi))
        , mElement(nullptr)
    {
        // Find the C-API Element. It contains required meta-information.
        const auto NumElements { db::simulink::GetCount<CapiElement>(MS.DataMapInfo.mmi) };
        auto Data { db::simulink::GetRawData<CapiElement>(MS.DataMapInfo.mmi) };

        // Search for the Element.
        for (std::size_t i {}; mElement == nullptr && i < NumElements; ++i)
        {
            std::string CurrentParameter { db::simulink::GetName<CapiElement>(MS.DataMapInfo.mmi, i) };
            if (CurrentParameter == PathAndName)
            {
                mElement = &Data[i];
                break;
            }
        }

        // Element found?
        if (mElement == nullptr)
        {
            std::ostringstream os;
            os << "Element " << PathAndName << " not found";

            CapiError Error;
            Error.Message = os.str();
            Error.Cause = ErrorType::NotFound;
            throw Error;
        }
    }

    template <typename T>
    T* ptr(const std::string MemberName)
    {
        T* Result {};

        auto Element { std::find_if(begin(), end(), [MemberName](auto& e) {
            if (MemberName == e.elementName)
                return true;
            return false;
        }) };

        if (Element != end())
        {
            auto Offset { Element->elementOffset };
            unsigned char* Pointer { reinterpret_cast<unsigned char*>(mData) };
            Pointer += Offset;
            Result = reinterpret_cast<T*>(Pointer);
        }

        return Result;
    }

    template <typename T>
    T& get(const std::string MemberName)
    {
        static_assert(EnableExceptions, "BusBuilder::get() is only available with Exceptions enabled.");
        auto Result { ptr<T>(MemberName) };
        if (Result == nullptr)
        {
            std::ostringstream os;
            os << "Element " << MemberName << " not found";

            CapiError Error;
            Error.Message = os.str();
            Error.Cause = ErrorType::NotFound;
            throw Error;
        }
        return *Result;
    }

    const rtwCAPI_ElementMap* begin()
    {
        auto DataTypeIndex { mElement->dataTypeIndex };
        rtwCAPI_DataTypeMap DataTypeEntry { mDataTypeMap[DataTypeIndex] };

        auto ElementMapIndex { DataTypeEntry.elemMapIndex };

        auto NumMembers { DataTypeEntry.numElements };
        const rtwCAPI_ElementMap* Members { &mElementMap[ElementMapIndex] };

        return Members;
    }

    const rtwCAPI_ElementMap* end()
    {
        auto DataTypeIndex { mElement->dataTypeIndex };
        rtwCAPI_DataTypeMap DataTypeEntry { mDataTypeMap[DataTypeIndex] };

        auto ElementMapIndex { DataTypeEntry.elemMapIndex };

        auto NumMembers { DataTypeEntry.numElements };
        const rtwCAPI_ElementMap* Members { &mElementMap[ElementMapIndex] };

        return Members + NumMembers;
    }

private:
    CapiAccessor<CapiElement, ModelStruct, EnableExceptions, DISABLE_TYPECHECKING> mAccessor;
    void* mData;
    const rtwCAPI_ElementMap* mElementMap;
    const rtwCAPI_DataTypeMap* mDataTypeMap;
    const CapiElement* mElement;
};
}

#endif