// Simulink CAPI - C++ header only library to interface with code generated by Simulink.
// Copyright (C) 2020-2021  Danish Belal
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License Version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

// \file

#include "CapiAccessor.hpp"
#include "TestCapiAccessorBase.hpp"
#include "gtest/gtest.h"

#include <cstring>
#include <optional>

extern "C"
{
#include "Controller.h"
}

class TestCapiAccessorNoExceptions : public TestCapiAccessorBase
{
protected:
    rtwCAPI_ModelMappingInfo& MMI() override
    {
        return ModelStruct.DataMapInfo.mmi;
    }
};

using BlockParameters = db::simulink::BlockParameters<db::simulink::DISABLE_EXCEPTIONS>;
using ModelParameters = db::simulink::ModelParameters<db::simulink::DISABLE_EXCEPTIONS>;
using States = db::simulink::States<db::simulink::DISABLE_EXCEPTIONS>;
using Signals = db::simulink::Signals<db::simulink::DISABLE_EXCEPTIONS>;

/// Verify the internal GetAddrMapIndex Function against some
/// magic numbers.
TEST_F(TestCapiAccessorNoExceptions, InternalGetAddrMapIndex)
{
    auto& MMI { ModelStruct.DataMapInfo.mmi };

    // Signals
    auto S1 { GetAddrMapIndex<rtwCAPI_Signals>("Controller/Discrete-Time Integrator") };
    auto S2 { GetAddrMapIndex<rtwCAPI_Signals>("Controller/ModelRef1") };
    auto S3 { GetAddrMapIndex<rtwCAPI_Signals>("Controller/AlgLoop") };
    EXPECT_EQ(S1, 0);
    EXPECT_EQ(S2, 5);
    EXPECT_EQ(S3, 11);

    // Blockparameters
    auto BP1 { GetAddrMapIndex<rtwCAPI_BlockParameters>("Controller/Constant/Value") };
    auto BP2 { GetAddrMapIndex<rtwCAPI_BlockParameters>("Controller/Discrete-Time Integrator/gainval") };
    auto BP3 { GetAddrMapIndex<rtwCAPI_BlockParameters>("Controller/AlgLoop/InitialCondition") };
    EXPECT_EQ(BP1, 12);
    EXPECT_EQ(BP2, 13);
    EXPECT_EQ(BP3, 20);

    // Modelparameters
    auto MP1 { GetAddrMapIndex<rtwCAPI_ModelParameters>("mMatrix") };
    auto MP2 { GetAddrMapIndex<rtwCAPI_ModelParameters>("X3_DD") };
    EXPECT_EQ(MP1, 23);
    EXPECT_EQ(MP2, 24);

    // Blockstates
    auto BS1 { GetAddrMapIndex<rtwCAPI_States>("Controller/Discrete-Time\nIntegrator/DSTATE") };
    auto BS2 { GetAddrMapIndex<rtwCAPI_States>("Controller/AlgLoop/DSTATE") };
    EXPECT_EQ(BS1, 21);
    EXPECT_EQ(BS2, 22);
}

/// Test `CapiAccessor::ptr` for invalid BlockParameters.
/// .
TEST_F(TestCapiAccessorNoExceptions, InvalidBlockParameterPtr)
{

    BlockParameters bp { MMI() };
    auto ptr { bp.ptr<double>("does/not/exist") };
    EXPECT_EQ(bp.Error().Cause, db::simulink::ErrorType::NotFound);
}

/// Test `CapiAccessor::ptr` for invalid ModelParameters.
/// .
TEST_F(TestCapiAccessorNoExceptions, InvalidModelParameterPtr)
{

    ModelParameters mp { MMI() };
    mp.ptr<double>("does-not-exist");
    EXPECT_EQ(mp.Error().Cause, db::simulink::ErrorType::NotFound);
}
